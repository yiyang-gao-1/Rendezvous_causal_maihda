---
title: "Conventional MAIHDA — ACIC 2022 Track 1a"
author: "Yiyang Gao"
date: "`r format(Sys.Date())`"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 3
    number_sections: true
  html_document:
    toc: true
    toc_depth: 3
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(tidyr)
  library(forcats)
  library(ggplot2)
  library(lme4)
  library(glue)
  library(broom.mixed)
})
```

# 1) Background: What is MAIHDA?

**MAIHDA** (Multilevel Analysis of Individual Heterogeneity and Discriminatory Accuracy) studies how outcomes differ across **intersectional strata** (e.g., combinations of demographic or contextual attributes). Key ideas:

-   **Random intercepts** for strata capture **baseline** differences between intersections with **partial pooling** (stabilises small groups).
-   **Random slopes** (e.g., for treatment) let the **effect** vary across strata.
-   We report **variance partition** (e.g., VPC/ICC) and, when modeling slopes, the **SD of the slope** and the **intercept–slope correlation**.

Here we use **ACIC 2022 Track-1a** (practice-randomised, patient outcomes by year).

------------------------------------------------------------------------

# 2) Load & Merge ACIC Track-1a

```{r load-merge}
# --- pick a replicate (1..1200 for Track 1a zip) ---
replicate_id_int <- 52
replicate_id <- sprintf("%04d", replicate_id_int)

# --- base path (edit to your local path) ---
base_dir <- "/Users/constanceko/Desktop/MAIHDA/ACIC_track1a_20220404"

# --- file paths ---
fp_patient_year  <- file.path(base_dir,"patient_year",  sprintf("acic_patient_year_%s.csv",  replicate_id))
fp_patient       <- file.path(base_dir,"patient",       sprintf("acic_patient_%s.csv",       replicate_id))
fp_practice      <- file.path(base_dir,"practice",      sprintf("acic_practice_%s.csv",      replicate_id))
fp_practice_year <- file.path(base_dir,"practice_year", sprintf("acic_practice_year_%s.csv", replicate_id))

# fast reader
rd <- function(p){
  stopifnot(file.exists(p))
  as.data.frame(fread(p, showProgress = TRUE))
}

# --- read ---
patient_year  <- rd(fp_patient_year)
patient       <- rd(fp_patient)
practice      <- rd(fp_practice)
practice_year <- rd(fp_practice_year)

# --- minimal typing / cleaning ---
patient_year  <- mutate(patient_year,  id.patient = as.integer(id.patient), year = as.integer(year))
patient       <- mutate(patient,       id.patient = as.integer(id.patient), id.practice = as.integer(id.practice))
practice      <- mutate(practice,      id.practice = as.integer(id.practice))
practice_year <- mutate(practice_year, id.practice = as.integer(id.practice), year = as.integer(year))

# drop practice-level Y if present (Track 1 outcome must be patient-level Y)
if ("Y" %in% names(practice_year))
  practice_year <- practice_year[ , setdiff(names(practice_year), "Y"), drop = FALSE]

# --- merge star schema (keep observed patient-years) ---
df <- patient_year %>%
  inner_join(patient,  by = "id.patient") %>%         # adds V1–V5, id.practice
  left_join(practice,  by = "id.practice")            # adds X1–X9

# append Z, post, n.patients, and any available practice-year aggregates (V*_C or V*_avg)
keep_cols <- intersect(
  c("id.practice","year","Z","post","n.patients",
    "V1_C","V2_C","V3_C","V4_C","V5_C","V1_avg","V2_avg","V3_avg","V4_avg","V5_avg"),
  names(practice_year)
)
df <- df %>%
  left_join(practice_year[, keep_cols, drop = FALSE], by = c("id.practice","year"))

# panel helpers and analysis variables
df <- df %>%
  arrange(id.patient, year) %>%
  group_by(id.patient) %>%
  mutate(Y_lag = dplyr::lag(Y)) %>%
  ungroup() %>%
  mutate(
    # Exposure: treated practice in post period
    W            = as.integer(Z == 1 & post == 1),
    year         = factor(year),
    id.practice  = factor(id.practice),
    id.patient   = factor(id.patient)
  )

# quick peek
dplyr::glimpse(df)
```

**Notes.**

-   Treatment is assigned at **practice × year** (`Z`), while the individual exposure is `W = 1` in post-treated practice-years.
-   Outcome `Y` is **patient-year** monthly average expenditure (simulated).
-   We keep patient-level `Y` and drop practice-level `Y`.

------------------------------------------------------------------------

# 3) Build Intersectional Strata

We create tertiles (low/medium/high) for two patient covariates (V1, V2) and, if it varies, for a practice covariate (X1). If X1 has only one level in this replicate, we fall back to V1×V2 only.

```{r strata}
# Helper: 3-quantile binning for a numeric variable (with tiny jitter for ties)
bin3 <- function(x, nm) {
  xj <- x + rnorm(length(x), sd = 1e-8)
  qs <- unique(quantile(xj, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE))
  if (length(qs) < 4) return(factor(paste0(nm, "_L")))
  cut(xj, qs, include.lowest = TRUE, labels = paste0(nm, c("_L","_M","_H")))
}

# Discretise
df <- df %>%
  mutate(
    V1_q = if ("V1" %in% names(.)) bin3(V1, "V1") else factor("V1_L"),
    V2_q = if ("V2" %in% names(.)) bin3(V2, "V2") else factor("V2_L"),
    X1_q = if ("X1" %in% names(.)) bin3(X1, "X1") else factor("X1_L")
  )

# If X1_q has <2 levels, drop it from strata
nlev <- sapply(df[,c("V1_q","V2_q","X1_q")], \(x) nlevels(droplevels(factor(x))))
use_X1 <- nlev["X1_q"] >= 2

df <- df %>%
  mutate(
    strata = if (use_X1)
               interaction(V1_q, V2_q, X1_q, drop = TRUE)
             else
               interaction(V1_q, V2_q, drop = TRUE)
  )

# Main effects used as fixed effects (drop any single-level)
main_terms <- c("V1_q","V2_q", if (use_X1) "X1_q" else NULL)
main_terms <- main_terms[sapply(df[main_terms], \(x) nlevels(droplevels(factor(x))) > 1)]

table(df$strata)[1:10]
```

------------------------------------------------------------------------

# 4) MAIHDA Models (A → B → C)

We follow a standard teaching flow (as in Leckie’s tutorials):

-   **Model A (fixed effects + practice RE):** baseline reference
-   **Model B (add strata random intercept):** baseline intersectional heterogeneity
-   **Model C (add treatment `W` + strata random slope):** treatment-effect heterogeneity across intersections

```{r models}
# Build formulas robustly
fA <- as.formula(paste("Y ~", paste(main_terms, collapse = " + "),
                       "+ (1|id.practice) + (1|id.patient)"))
fB <- as.formula(paste("Y ~", paste(main_terms, collapse = " + "),
                       "+ (1|id.practice) + (1|id.patient) + (1|strata)"))
fC <- as.formula(paste("Y ~ W +", paste(main_terms, collapse = " + "),
                       "+ (1|id.practice) + (1|id.patient) + (1 + W|strata)"))



           
mA <- lmer(fA, data = df, REML = TRUE)
mB <- lmer(fB, data = df, REML = TRUE)

# a mild convergence note for Model C. We can center/scale predictors, center W to 0/1 or ±0.5, and try an alternative optimizer if needed
df <- df %>% mutate(Wc = W - mean(W))
mC <- lmer(fC, data = df, REML = TRUE, control = lmerControl(optimizer="bobyqa"))

summary(mA)
summary(mB)
summary(mC)
```

**Why a practice random intercept?** Track-1a is **cluster-randomised at practice** (over time). Including `(1|id.practice)` respects the assignment level and improves inference.

------------------------------------------------------------------------

# 5) Diagnostics & Visuals

```{r vpc-pcv}

# VPC/ICC for strata in Model A
# PCV is meaningful when comparing nested models that both include the same RE;
# for MAIHDA, often we compare B vs a model with fixed “additive” terms only.
vcA <- as.data.frame(VarCorr(mA))
sig_strata_A <- 0        # no strata in A
sig_strata_B <- vcB$vcov[vcB$grp=="strata" & vcB$var1=="(Intercept)" & is.na(vcB$var2)]



# VPC/ICC for strata in Model B
vcB <- as.data.frame(VarCorr(mB))
sigma_strata_B <- vcB$vcov[vcB$grp == "strata" & vcB$var1 == "(Intercept)"]
sigma_resid_B  <- sigma(mB)^2
VPC_B <- sigma_strata_B / (sigma_strata_B + sigma_resid_B)

sprintf("VPC (strata; Model B) = %.6f", VPC_B)
```

```{r slope-dist, fig.width=7, fig.height=4}
# Random slopes of W in Model C
reC <- ranef(mC)$strata
stopifnot(ncol(reC) >= 2) # columns: Intercept, W
colnames(reC)[1:2] <- c("Intercept_RE","W_slope_RE")

ggplot(as.data.frame(reC), aes(x = W_slope_RE)) +
  geom_histogram(bins = 24) +
  labs(
    title = "Distribution of strata-specific treatment slopes (Model C)",
    x = "Deviation from overall W effect", y = "Number of strata"
  ) +
  theme_minimal()
```

------------------------------------------------------------------------

# 6) Results (auto summary + interpretation)

```{r results-auto}
# Fixed effect (ATE proxy) for W in Model C
coefs <- broom.mixed::tidy(mC, effects = "fixed")
ate_row <- coefs[coefs$term == "W", ]
ATE_W   <- ate_row$estimate
SE_W    <- ate_row$std.error
t_W     <- ate_row$statistic

# Variance components for strata in Model C
vcC <- as.data.frame(VarCorr(mC))
sd_W   <- sqrt(vcC$vcov[vcC$grp=="strata" & vcC$var1=="W" & is.na(vcC$var2)])
sd_int <- sqrt(vcC$vcov[vcC$grp=="strata" & vcC$var1=="(Intercept)" & is.na(vcC$var2)])
cov_iw <- vcC$vcov[vcC$grp=="strata" & vcC$var1=="(Intercept)" & vcC$var2=="W"]
corr_iw <- cov_iw/(sd_W*sd_int)


# Re-compute VPC for Model B (printed above)
VPC_B <- as.numeric(VPC_B)

cat(glue("
**Auto-reported summary (Model C)**  
- Fixed effect of W (ATE proxy): {round(ATE_W, 2)} (SE {round(SE_W, 2)}, t = {round(t_W, 2)})  
- Strata VPC (Model B): {round(VPC_B, 4)}  
- SD of W random slope (strata): {round(sd_W, 2)}  
- Corr(Intercept, W) at strata: {round(corr_iw, 2)}
"))
```

```{r interpretation, results='asis'}
# One-paragraph interpretation using the numbers above
low  <- ATE_W - 2*sd_W
high <- ATE_W + 2*sd_W
cat(glue("
**Interpretation (reader-friendly):**  
On average, exposure in treated post-periods (W = 1) is associated with an increase in the outcome of about **{round(ATE_W,0)}** units (SE {round(SE_W,1)}).  
Baseline differences between intersectional strata are **{ifelse(VPC_B < 0.02, 'very small', ifelse(VPC_B < 0.05, 'modest', 'substantial'))}** (VPC ≈ {round(100*VPC_B,1)}%).  
However, **treatment effects vary across strata**: the random-slope SD is about **{round(sd_W,1)}**, suggesting many strata lie roughly between **{round(low,0)}** and **{round(high,0)}** around the average effect.  
The **negative/positive** correlation between strata intercepts and W slopes (corr ≈ {round(corr_iw,2)}) indicates that strata with **{ifelse(corr_iw < 0, 'lower baselines tend to benefit more', 'higher baselines tend to benefit more')}**.
"))
```

------------------------------------------------------------------------

# 7) Notes & Tips

-   If a binned covariate collapses to one level in a replicate (e.g., `X1_q`), we automatically drop it from fixed effects and from the strata definition.
-   If a model becomes **singular** (a variance ≈ 0), that’s informative: the data do not support that random component for this replicate.
-   Given Track-1a’s design, keeping a **practice random intercept** is good practice.
